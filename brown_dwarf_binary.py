# -*- coding: utf-8 -*-
"""Brown_Dwarf_Binary

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zCFRvSojNF9IIsKr_DLyx3rXX0FcH9dQ
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing packages
import pandas as pd
import numpy as np
from scipy import stats
from statsmodels.stats import weightstats as stests
import matplotlib.pyplot as plt
# %matplotlib inline
import math as mth
from statsmodels.stats.proportion import proportions_ztest
from scipy.stats import norm
from scipy.optimize import minimize
from scipy.stats import ttest_ind
import scipy.stats as stats
import seaborn as sns
from scipy.stats import binom

# Mounting and importing our binary and total data set
from google.colab import drive
drive.mount('/content/drive')
datamain = pd.read_csv('/content/drive/MyDrive/ASTR200/UltracoolSheet - Main.csv')

# Preview the dataframe shape for the whole data set, columns and first 5 rows
print('Shape of data: ', datamain.shape, '\n'*2)
print(datamain.columns,'\n'*2)
datamain.head()

# Clean up our data set
selected_datamain = datamain[['name', 'youth_evidence', 'multiplesystem_unresolved_in_this_table', 'multiplesystem_resolved_in_this_table', 'age_singlevalue_gyr_formula']]

# Preview the selected columns
print('Shape of data with relevant columns only: ', selected_datamain.shape, '\n'*2)
selected_datamain.head()

# Makes a single array for each column that is relevant
names = np.array(datamain["name"]) # get all the names of the brown dwarfs
youth_evi = np.array(datamain["youth_evidence"]) #get corresponding youth evidence, yes means young and no means old
age_single = np.array(datamain["age_singlevalue_gyr_formula"]) #age single gives us the estimate of the year in Gyr
age_w_err = np.array(datamain["age_distribution_gyr_formula"])#error for age

#not in a multiple system

#This organizes the data and takes out all of the columns that have either a resolved or unresolved multiple (part of a binary)
N_nonbins_half = selected_datamain[selected_datamain["multiplesystem_unresolved_in_this_table"].isin(["N"])]
N_nonbins = N_nonbins_half[N_nonbins_half["multiplesystem_resolved_in_this_table"].isin(["N"])]

#in a multiple system

# From the above subset, select rows where 'multiplesystem_resolved_in_this_table' and 'multiplesystem_unresolved_in_this_table' is not 'N'
non_N_unresolved = selected_datamain[~selected_datamain["multiplesystem_unresolved_in_this_table"].isin(["N"])]
non_N_resolved = selected_datamain[~selected_datamain["multiplesystem_resolved_in_this_table"].isin(["N"])]
combined_df = pd.concat([non_N_unresolved, non_N_resolved], ignore_index=True)
Y_bins = combined_df.drop_duplicates()

#binaries data sheet
binaries = pd.read_csv('/content/drive/MyDrive/ASTR200/UltracoolSheet - Binaries.csv')

#Binary system sorting
all_bin = binaries[binaries["name"].isin(Y_bins['name'])]

y_bin_AB = all_bin[all_bin['designation_binary'] == "AB"]

y_binaries = datamain[datamain["name"].isin(y_bin_AB['name'])]

#binary brown dwarfs with young evidence anything but N (considered young)
#(young brown dwarfs in a binary system)
young_binaries = Y_bins[Y_bins['youth_evidence'] != "N"]

#brown dwarfs not in any multiple system (considered singles) with young evidence anything but N (considered young)
#(young single brown dwarfs)
young_singles = N_nonbins[N_nonbins["youth_evidence"] != "N"]

#filtering all the binary systems that appear on the binary sheet
#do this to check which of the binary systems are made of only brown dwarfs or have a brown dwarf as the primary component
# consider the systems with designation binary AB as the ones made of only brown dwarfs or have brown dwarf as the primary component
young_binary_systems = binaries[binaries["name"].isin(young_binaries['name'])]

#young brown dwarfs systems
brown_dwarf_YBS = young_binary_systems[young_binary_systems["designation_binary"] == "AB"]

#total young brown dwarfs. the sum of the young brown dwarf systems + young single brown dwarfs
total_young_brown_dwarfs = len(brown_dwarf_YBS) + len(young_singles)  # singles and binaries

#binary fraction is the ratio of the total young brown dwarf binary systems over the total young brown dwarfs
binary_fraction_young = len(brown_dwarf_YBS)/total_young_brown_dwarfs
binary_fraction_young

##binary brown dwarfs with young evidence equals N (considered old)
#(old brown dwarfs in a binary system)
old_binaries = Y_bins[Y_bins['youth_evidence'] == "N"]
#single old brown dwarfs (not in any multiple systems)
old_singles = N_nonbins[N_nonbins["youth_evidence"] == "N"]
#all the old brown dwarfs that can be found on the binaries sheet
old_binary_system = binaries[binaries["name"].isin(old_binaries['name'])]
#old brown dwarfs with designation binary as AB (either the primary component is a brown dwarf or both are brown dwarfs)
brown_dwarf_OBS = old_binary_system[old_binary_system["designation_binary"] == "AB"]

#total old brown dwarfs. the sum of the old brown dwarf systems + old single brown dwarfs
total_old_brown_dwarfs = len(brown_dwarf_OBS) + len(old_singles)  # singles and binaries

##binary fraction is the ratio of the total old brown dwarf binary systems over the total old brown dwarfs
binary_fraction_old = len(brown_dwarf_OBS)/total_old_brown_dwarfs
binary_fraction_old

ages_binary = np.array(y_binaries['age_singlevalue_gyr_formula'])  # Ages of binary dwarfs
ages_non_binary = np.array(N_nonbins['age_singlevalue_gyr_formula'])  # Ages of non-binary dwarfs
# Initial mean and median for our 'observations'
print("bin mean=",np.mean(ages_binary))
print("nonbin mean=",np.mean(ages_non_binary))

# Bar plot showing the binary fractions for the old and young brown dwarfs, categorized by Youth Evidence flag

# Data
categories = ['Young Brown Dwarfs', 'Old Brown Dwarfs',]
binary_fractions = [binary_fraction_young, binary_fraction_old]
# Plotting
plt.bar(categories, binary_fractions, color=['blue', 'orange'])
plt.xlabel('Flagged for Youth Evidence (Young) vs. Not Flagged (Old)')
plt.ylabel('Binary Fraction')
plt.title('Binary Fraction For Old and Young Brown Dwarfs (Organized by Youth'
' Evidence flag)')
plt.ylim(0, .1)
plt.show()

# Plot histograms of ages of binary and non-binary dwarfs
plt.hist(ages_binary, bins=15, alpha=0.5, label='Dwarfs in Binary Systems', color='blue', density = True)
plt.hist(ages_non_binary, bins=15, alpha=0.5, label='Dwarfs Not in Binary Systems', color='orange', density = True)

# Add labels and legend
plt.xlabel('Age (Gya)')
plt.ylabel('Frequency')
plt.title('Ages of Binary and Non-Binary Dwarfs')
plt.legend()

# Show plot
plt.show()

# Observed test statistic (difference in means)
observed_statistic_non = np.mean(ages_non_binary)
observed_statistic_bin = np.mean(ages_binary)

# Number of times to run the simulation
n = 5000

# Initialize array to store simulated test statistics
simulated_statisticsbin = np.zeros(n)
simulated_statisticsnon = np.zeros(n)

# Perform Monte Carlo simulation
for i in range(n):
    # Simulate data
    simulated_ages_binary = np.random.choice(ages_binary, size=len(ages_binary), replace=True)
    simulated_ages_non_binary = np.random.choice(ages_non_binary, size=len(ages_non_binary), replace=True)

    # Calculate test statistic for simulated data
    simulated_statisticnon =  np.mean(simulated_ages_non_binary)
    simulated_statisticbin =  np.mean(simulated_ages_binary)
    # Store simulated test statistic
    simulated_statisticsbin[i] = simulated_statisticbin
    simulated_statisticsnon[i] = simulated_statisticnon

print('obnon =',observed_statistic_non)
print('obbin =',observed_statistic_bin)
print('simnon=',simulated_statisticnon)
print('simbin =',simulated_statisticbin)

#Plots histograms of simulated distributions
plt.hist(simulated_statisticsbin, bins=15, alpha=.7, label='Simulated Statistics Binary System')
plt.hist(simulated_statisticsnon, bins=15, alpha=.7, label='Simulated Statistics Not Binary System')
#Plots line at observed statistics
plt.axvline(x=observed_statistic_non, color='red', linestyle='--', label = 'observed statistic non binary')
plt.axvline(x=observed_statistic_bin, color='blue', linestyle='--', label = 'observed statistic binary')
plt.xlabel('Mean Age Value (Gya)')
plt.ylabel('Count')
plt.legend(loc = 'lower left', fontsize ='10')
plt.title('Simulated Distributions')

# z-test for means for above distributions
mean_sim_bin = np.mean(simulated_statisticsbin)
print(mean_sim_bin)
mean_sim_non = np.mean(simulated_statisticsnon)
print(mean_sim_non)
std_dev_sim_bin = np.std(simulated_statisticsbin)
std_dev_sim_non = np.std(simulated_statisticsnon)
standard_error_diff = np.sqrt((std_dev_sim_bin ** 2) / n + (std_dev_sim_non ** 2) / n)
z_score = abs((mean_sim_bin - mean_sim_non) / standard_error_diff)
print(z_score)
p_value = 2 * (1 - stats.norm.cdf(abs(z_score)))
if p_value < 0.05:
    print("Reject null hypothesis: There is a significant difference in means between binary and non-binary groups.")
else:
    print("Fail to reject null hypothesis: There is no significant difference in means between binary and non-binary groups.")
print(p_value)

"""Bayesian Inferance:"""

# Trying to do youth evidence like lab 7 chances of landing on water
# look at binary set and perform a  bayesian inference with ratio of youth evidence vs total number of points in data set
# look at nonbinary set and do bayesian inference again with the same process
#then look at peak values from these and perform a z-test to see if the difference in probability of youth-evidence is signfiicantly significant

sns.set_context('talk')

nsamp = 100  #sample size
p = np.linspace(0,1,nsamp) #sampling
p

# Set variable to find counts of variables
value_counts = y_binaries["youth_evidence"].value_counts()

# Get the count of entries with value 'N'
count_N = value_counts.get('N', 0)

# Get the count of entries without value 'N' in the restricted data set
count_not_N = len(y_binaries) - count_N

print(count_N)
print(count_not_N)

# storing the value of young brown dwarves in multiple system that will be used for Bayesian
bin_young = count_not_N

value_counts2 = N_nonbins["youth_evidence"].value_counts()
# Get the count of entries with value 'N'
count_N2 = value_counts2.get('N', 0)

# Get the count of entries without value 'N'
count_not_N2 = len(N_nonbins) - count_N2

# storing the value of young brown dwarves in NOT in multiple system that will be used for Bayesian
non_bin_young = count_not_N2

print(count_N2)
print(count_not_N2)

k = 165 # number of brown dwarves in binary system

m = 3670 # number of brown dwarves not in binary system or believed not to be

def likelihood_func(bin, n, p):
    """ Returns binomial likelihood.
    Inputs:
        bin (int): number of binaries
        n (int): total number of data points from data set
        p (array): array of hypothesis
    Outputs:
        Lp (array): array of binomial likelihoods
    """

    Lp = binom.pmf(bin, n, p, loc=0)

    return Lp


def uniform_prior(p):
    """ Returns a constant prior.
    Inputs:
        p (array): array of hypothesis
    Outputs:
        p1 (array): array of constant priors
    """
    p1=np.repeat(.5, len(p))
    return p1

"""RUNNING BAYESIAN INFERENCE FOR BROWN DWARFS IN MULTIPLE SYSTEM"""

young =   52 #number of young brown dwarves in set
n =  165 # total number of brown dwarves in set

#employ our likelihood function
likelihood = likelihood_func(young, n, p)

# using a uniform prior
prior = uniform_prior(p)

#posterior is proportional to the likelihood times the prior. Applying Bayes' rule:
unnormed_posterior = likelihood * prior

#  properly normalize by the evidence
posterior = unnormed_posterior/unnormed_posterior.sum()
posterior

def binom_post_grid_approx(prior, points, k, n):
  """ Returns a posterior.
    Inputs:
        prior (array): given array of prior hypotheses
        points (int): the number of points to create a grid of prior values
        k (int): number of successes/points that are young
        n (int): number of data points
    Outputs:
        posterior (array): array of posterior distribution
    """
  p = np.linspace(0,1,points)
  Lp = binom.pmf(k, n, p)
  unnormed_posterior = Lp * prior
  posterior = unnormed_posterior/unnormed_posterior.sum()
  return posterior

# Define the points at which to sample the probability space
points = (20, 200, 1000)

# Initialize arrays to store sampled probability grids and corresponding posteriors
array_of_ps = []
array_of_posteriors = []

# Create subplots with a layout corresponding to the number of points, and set the main title
_, ax = plt.subplots(1, len(points), figsize=(6 * len(points), 5))
plt.suptitle("Probability of Youth Evidence in the Binary Brown Dwarf Set", fontsize=20)

# Iterate through each point and create posterior distributions
for idx, ps in enumerate(points):
    # Generate a probability grid
    p_grid = np.linspace(0, 1, ps)
    array_of_ps.append(p_grid)  # Store the probability grid for later use

    # Calculate the posterior distribution using binomial approximation
    posterior = binom_post_grid_approx(uniform_prior(p_grid), ps, young, n)
    array_of_posteriors.append(posterior)  # Store the posterior distribution

    # Plot the posterior distribution on the corresponding subplot
    ax[idx].plot(p_grid, posterior, "o-", label=f"successes = {young}\ntosses = {n}")
    ax[idx].set_xlabel("Probability of Positive Youth Evidence")
    ax[idx].set_ylabel("Posterior Probability")
    ax[idx].set_title(f"Testing {ps} sample points")
    ax[idx].legend(loc=0)
# Adjust the layout of subplots to prevent overlap
plt.tight_layout()

# Initialize a counter for accessing posteriors
j = 0

# Iterate through each probability grid
for i in array_of_ps:
    # Find the index of the maximum posterior probability in the corresponding posteriors
    max_p = np.argmax(array_of_posteriors[j])

    # Extract the probability value corresponding to the maximum posterior probability
    prob = i[max_p]

    # Increment the counter for accessing next posterior
    j += 1

    # Print the result
    print("Posterior for ", len(i), "number of points is ", prob)

# Calculate the standard deviation of the last posterior distribution in the loop and print
std_dev = np.std(posterior)
print(f"Standard deviation for {ps} points:", std_dev)

"""NOW RUNNING BAYESIAN INFERENCE FOR BROWN DWARFS NOT IN MULTIPLE SYSTEM"""

young_non =   551 #number of young brown dwarves in set
n_non =  3670 # total number of brown dwarves in set

#employ our likelihood function
likelihood = likelihood_func(young_non, n_non, p)

# using a uniform prior
prior = uniform_prior(p)

#posterior is proportional to the likelihood times the prior. Applying Bayes' rule:
unnormed_posterior = likelihood * prior

#  properly normalize by the evidence
posterior = unnormed_posterior/unnormed_posterior.sum()
posterior

# Define the points at which to sample
points = (20, 200, 1000)

# creates arrays to store sampled probability grids and corresponding posteriors
array_of_ps = []
array_of_posteriors = []

# Create subplots with a layout corresponding to the number of points, and sets the main title
_, ax = plt.subplots(1, len(points), figsize=(6 * len(points), 5))
plt.suptitle("Probability of Youth Evidence in the Non-Binary Brown Dwarf Set", fontsize=20)

# Iterate through each point and create posterior distributions
for idx, ps in enumerate(points):
    # Generate a probability grid
    p_grid = np.linspace(0, 1, ps)
    array_of_ps.append(p_grid)  # Store the probability grid for later use

    # Calculate the posterior distribution using binomial approximation
    posterior = binom_post_grid_approx(uniform_prior(p_grid), ps, young_non, n_non)
    array_of_posteriors.append(posterior)  # Store the posterior distribution

    # Plot the posterior distribution on the corresponding subplot
    ax[idx].plot(p_grid, posterior, "o-", label=f"successes = {young_non}\ntosses = {n_non}")
    ax[idx].set_xlabel("Probability of Positive Youth Evidence")
    ax[idx].set_ylabel("Posterior Probability")
    ax[idx].set_title(f"Testing {ps} sample points")
    ax[idx].legend(loc=0)
# Adjust the layout of subplots to prevent overlap
plt.tight_layout()

# Initialize a counter for posteriors
j = 0

# Iterate through each probability grid
for i in array_of_ps:
    # Find the index of the maximum posterior probability in the corresponding posteriors
    max_p = np.argmax(array_of_posteriors[j])

    #  find probability value corresponding to the maximum posterior probability
    prob = i[max_p]

    # Increment the counter for next posterior
    j += 1

    # Print the result
    print("Posterior for ", len(i), "number of points is ", prob)

# Calculate the standard deviation of the last posterior distribution in the loop and print
std_dev = np.std(posterior)
print(f"Standard deviation for {ps} points:", std_dev)

# z-test comparing probability of there being youth evidence in binary and non-binary Brown Dwarf sets
post_diff = 0.3153153153153153 - 0.15015015015015015  # posterior of the binary and non-binary set at 1000 points
std_binaries = 0.0026185760745702155 #standard deviations from both sets
std_non_binaries = 0.0068482448527417755

# implementing z-test with above values
# Calculate standard error of the difference between means
standard_error_diff = np.sqrt((std_non_binaries ** 2) / n + (std_binaries ** 2) / n)
#find z-score
z_score = (post_diff) / standard_error_diff
print("The z-score is", z_score)
#convert z-score into p-score
p_value = 2 * (1 - stats.norm.cdf(abs(z_score)))
# Check if the p-value is less than the significance level (0.05)
if p_value < 0.05:
    print("Reject null hypothesis: There is a significant difference in means between binary and non-binary groups.")
else:
    print("Fail to reject null hypothesis: There is no significant difference in means between binary and non-binary groups.")
print(p_value)
#p-value estimates as 0.0 because of the very large z-score